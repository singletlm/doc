<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>力扣</title>
</head>

<body>

</body>

</html>
<script>
  // 1.两数之和
  /**
   * @param {number[]} nums
   * @param {number} target
   * @return {number[]}
   */
  var twoSum = function (nums, target) {
    let len = nums.length
    while (len) {
      let a = nums.pop()
      let b = target - a
      for (let i = 0; i < nums.length; i++) {
        if (nums[i] === b) {
          return [i, nums.length]
        }
      }
      len = nums.length
    }

    // 神仙操作
    // return nums.reduce((p, v, i, ar) => p[v] !== undefined && ar.splice(1) && [p[v], i] || (i === p['l'] ? [] : p[
    //   target -
    //   v] = i, p), {
    //   l: nums.length - 1
    // })
  };

  // 7.整数反转
  /**
   * @param {number} x
   * @return {number}
   */
  var reverse = function (x) {
    let now = Math.abs(x).toString().split("").reverse().join("");
    if (x < 0) {
      return now <= Math.pow(2, 31) ? -now : 0;
    } else {
      return now < Math.pow(2, 31) ? now : 0;
    }

    // let result = 0;
    // while (x !== 0) {
    //   result = result * 10 + x % 10;
    //   x = (x / 10) | 0;
    // }
    // return (result | 0) === result ? result : 0;
  }

  // 9.回文数
  /**
   * @param {number} x
   * @return {boolean}
   */
  var isPalindrome = function (x) {
    return x.toString().split("").reverse().join("") === x.toString()
  };

  // 13. 罗马数字转整数
  /**
   * @param {string} s
   * @return {number}
   */
  var romanToInt = function (s) {
    const hashMap = {
      "I": 1,
      "V": 5,
      "X": 10,
      "L": 50,
      "C": 100,
      "D": 500,
      "M": 1000
    }
    // IV 4 = 5 - 1 （左边 < 右边 右边 - 左边）
    // VI 6 = 5 + 1 （左边 > 右边 右边 + 左边)
    // 判断左边是不是小于右边，小于就-，大于就+
    let result = 0
    for (let i = 0; i < s.length; i++) {
      hashMap[s[i]] < hashMap[s[i + 1]] ? result -= hashMap[s[i]] : result += hashMap[s[i]]
    }
    return result
  };

  // 14.最长公共前缀
  /**
   * @param {string[]} strs
   * @return {string}
   */
  var longestCommonPrefix = function (strs) {
    if (!strs.length) return ''
    let result = strs[0]
    for (let i = 1; i < strs.length; i++) {
      let j = 0
      for (; j < result.length && j < strs[i].length; j++) {
        if (result.charAt(j) !== strs[i].charAt(j)) break
      }
      result = result.substring(0, j)
      if (result === "") return ""
    }
    return result
  };

  // 20. 有效的括号
  /**
   * @param {string} s
   * @return {boolean}
   */
  var isValid = function (s) {
    if (!s) return true
    let len = s.length
    if (len % 2) return false
    let arr = []

    for (let i = 0; i < len; i++) {
      let letter = s[i]
      switch (letter) {
        case "(": {
          arr.push(letter)
          break;
        }
        case "[": {
          arr.push(letter)
          break;
        }
        case "{": {
          arr.push(letter)
          break;
        }
        case ")": {
          if (arr.pop() !== "(")
            return false
          break;
        }
        case "]": {
          if (arr.pop() !== "[")
            return false
          break;
        }
        case "}": {
          if (arr.pop() !== "{")
            return false
          break;
        }
      }
    }
    return !arr.length
  };

  // 21. 合并两个有序链表
  /**
   * Definition for singly-linked list.
   * function ListNode(val, next) {
   *    this.val = (val===undefined ? 0 : val)
   *    this.next = (next===undefined ? null : next)
   * }
   */
  /**
   * @param {ListNode} l1
   * @param {ListNode} l2
   * @return {ListNode}
   */
  var mergeTwoLists = function (l1, l2) {
    if (l1 === null) {
      return l2;
    } else if (l2 === null) {
      return l1;
    } else if (l1.val < l2.val) {
      l1.next = mergeTwoLists(l1.next, l2);
      return l1;
    } else {
      l2.next = mergeTwoLists(l1, l2.next);
      return l2;
    }
  };

  // 26. 删除排序数组中的重复项
  /**
   * @param {number[]} nums
   * @return {number}
   */
  var removeDuplicates = function (nums) {
    // let last = nums[nums.length - 1];
    // for (let i = nums.length - 2; i >= 0; i--) {
    //   if (nums[i] === last) {
    //     nums.splice(i, 1);
    //   } else {
    //     last = nums[i];
    //   }
    // }
    // return nums.length;


    // 滑动窗口
    // let idx = 0,
    //   nowIdx, pass = 0;
    // while (idx + pass + 1 < nums.length) {
    //   nowIdx = idx + pass + 1;
    //   if (nums[idx] === nums[nowIdx]) {
    //     pass++;
    //   } else {
    //     idx++;
    //     [nums[idx], nums[nowIdx]] = [nums[nowIdx], nums[idx]];
    //   }
    // }
    // return idx + 1;


    // 双指针
    // let left = 0,
    //   right = 1;
    // while (right < nums.length) {
    //   if (nums[left] !== nums[right]) {
    //     nums[++left] = nums[right];
    //   }
    //   right++;
    // }
    // return left + 1;

  };


  // 27. 移除元素
  /**
   * @param {number[]} nums
   * @param {number} val
   * @return {number}
   */
  var removeElement = function (nums, val) {
    // for (let i = nums.length; i--;) {
    //   if (nums[i] === val) {
    //     nums.splice(i, 1)
    //   }
    // }
    // return nums.length
  };


  // 28. 实现 strStr()
  /**
   * @param {string} haystack
   * @param {string} needle
   * @return {number}
   */
  var strStr = function (haystack, needle) {
    // return haystack.indexOf(needle)
    if (needle === "") return 0
    for (var i = 0; i <= haystack.length - needle.length; i++) {
      if (haystack[i] === needle[0] && haystack.substr(i, needle.length) === needle) return i
    }
    return -1
  };


  // 35. 搜索插入位置
  /**
   * @param {number[]} nums
   * @param {number} target
   * @return {number}
   */
  var searchInsert = function (nums, target) {
    // const n = nums.length;
    // let left = 0,
    //   right = n - 1,
    //   ans = n;
    // while (left <= right) {
    //   let mid = ((right - left) >> 1) + left;
    //   if (target <= nums[mid]) {
    //     ans = mid;
    //     right = mid - 1;
    //   } else {
    //     left = mid + 1;
    //   }
    // }
    // return ans;
    const n = nums.length;
    let l = 0,
      r = n - 1,
      ans = n;
    while (left <= right) {
      let mid = Math.floor((right - left) / 2) + left;
      if (target <= nums[mid]) {
        ans = mid;
        right = mid - 1;
      } else {
        left = mid + 1;
      }
    }
    return ans;
  };


  // 38. 外观数列
  /**
   * @param {number} n
   * @return {string}
   */
  var countAndSay = function (n) {
    let ans = '1'
    for (let i = 1; i < n; i++) {
      let l = 0,
        r = 1,
        str = '';
      while (r <= ans.length) {
        if (ans[l] !== ans[r]) {
          str += (r - l) + ans[l]
          l = r
        }
        r++
      }
      ans = str
    }
    return ans
  };


  // 53. 最大子序和
  /**
   * @param {number[]} nums
   * @return {number}
   */
  var maxSubArray = function (nums) {
    let ans = nums[0]
    let sum = 0
    for (const num of nums) {
      if (sum > 0) {
        sum += num
      } else {
        sum = num
      }
      ans = Math.max(ans, sum)
    }
    return ans
  };


  // 58. 最后一个单词的长度
  /**
   * @param {string} s
   * @return {number}
   */
  var lengthOfLastWord = function (s) {
    if (s.length) {
      s = s.trim()
      let arr = s.split(' ')
      return arr[arr.length - 1].length
    }
    return 0
  };


  // 66. 加一
  /**
   * @param {number[]} digits
   * @return {number[]}
   */
  var plusOne = function (digits) {
    if (digits && digits.length) {
      let i = digits.length - 1
      for (; i > -1; i--) {
        if (digits[i] === 9) {
          digits[i] = 0
        } else {
          digits[i] += 1
          break
        }
      }
      return i === -1 ? [1].concat(digits) : digits
    }
    return [1]
  };


  // 67. 二进制求和
  /**
   * @param {string} a
   * @param {string} b
   * @return {string}
   */
  var addBinary = function (a, b) {
    let _a = a.split("").reverse(),
      _b = b.split("").reverse(),
      carry = 0,
      result = [];
    for (let i = 0; i < Math.max(_a.length, _b.length); i++) {
      _a[i] = Number(_a[i]) || 0;
      _b[i] = Number(_b[i]) || 0;
      let x = _a[i] + _b[i] + carry;
      carry = x >= 2 ? 1 : 0;
      result[i] = x % 2;
    }
    return carry ? result.concat([1]).reverse().join('') : result.reverse().join('');
  };


  // 69. x 的平方根
  /**
   * @param {number} x
   * @return {number}
   */
  var mySqrt = function (x) {
    if (x < 2) return x
    // 可以从2开始，边界已经先判断了
    let left = 2,
      mid,
      right = Math.floor(x / 2);
    while (left <= right) {
      mid = ((right - left) >> 1) + left
      if (mid * mid === x) return mid
      if (mid * mid < x) {
        left = mid + 1
      } else {
        right = mid - 1
      }
    }
    return right
  };


  // 70. 爬楼梯
  /**
   * @param {number} n
   * @return {number}
   */
  var climbStairs = function (n) {
    // return n < 2 ? 1 : climbStairs(n - 1) + climbStairs(n - 2)
    // 尾递归优化
    function add(a, s1 = 1, s2 = 1) {
      if (a <= 1) return s2;
      return add(a - 1, s2, s1 + s2)
    }
    return add(n)
  };


  // 83. 删除排序链表中的重复元素
  /**
   * Definition for singly-linked list.
   * function ListNode(val) {
   * this.val = val;
   * this.next = null;
   * }
   */
  /**
   * @param {ListNode} head
   * @return {ListNode}
   */
  var deleteDuplicates = function (head) {
    let cur = head;
    while (cur && cur.next) {
      if (cur.val == cur.next.val) {
        cur.next = cur.next.next;
      } else {
        cur = cur.next;
      }
    }
    return head;
  };


  // 88. 合并两个有序数组
  /**
   * @param {number[]} nums1
   * @param {number} m
   * @param {number[]} nums2
   * @param {number} n
   * @return {void} Do not return anything, modify nums1 in-place instead.
   */
  var merge = function (nums1, m, nums2, n) {
    let idx1 = m - 1,
      idx2 = n - 1,
      tail = m + n - 1;
    while (idx2 >= 0) {
      // nums1[tail--] = (nums1[idx1] > nums2[idx2]) ? nums1[idx1--] : nums2[idx2--]
      // if (nums1[idx1] > nums2[idx2]) {
      //   nums1[tail] = nums1[idx1]
      //   idx1--
      // } else {
      //   nums1[tail] = nums2[idx2]
      //   idx2--
      // }
      // tail--
    }
  };


  // 100. 相同的树
  /**
   * Definition for a binary tree node.
   * function TreeNode(val, left, right) {
   * this.val = (val===undefined ? 0 : val)
   * this.left = (left===undefined ? null : left)
   * this.right = (right===undefined ? null : right)
   * }
   */
  /**
   * @param {TreeNode} p
   * @param {TreeNode} q
   * @return {boolean}
   */
  var isSameTree = function (p, q) {
    if (p == null && q == null) return true;
    if (p == null || q == null) return false;
    if (p.val != q.val) return false;
    return isSameTree(p.left, q.left) && isSameTree(p.right, q.right);
  };


  // 101. 对称二叉树
  /**
   * Definition for a binary tree node.
   * function TreeNode(val) {
   * this.val = val;
   * this.left = this.right = null;
   * }
   */
  /**
   * @param {TreeNode} root
   * @return {boolean}
   */
  var isSymmetric = function (root, c) {
    // 左右都为空 或者 左右都有值 且 左值等于右值 且 左边左等于右边右 且 左边右等于右边左
    return c = (l, r) => l === null && r === null || l && r && l.val === r.val && c(l.left, r.right) && c(r.left, l
      .right), !!c(root, root)
    // let c = xxxx
    // return !!c(root, root)
  }


  // 104. 二叉树的最大深度
  /**
   * Definition for a binary tree node.
   * function TreeNode(val) {
   * this.val = val;
   * this.left = this.right = null;
   * }
   */
  /**
   * @param {TreeNode} root
   * @return {number}
   */
  var maxDepth = function (root) {
    if (!root) {
      return 0;
    } else {
      const left = maxDepth(root.left);
      const right = maxDepth(root.right);
      return Math.max(left, right) + 1;
    }
  };


  // 107. 二叉树的层次遍历 II
  /**
   * Definition for a binary tree node.
   * function TreeNode(val) {
   * this.val = val;
   * this.left = this.right = null;
   * }
   */
  /**
   * @param {TreeNode} root
   * @return {number[][]}
   */
  var levelOrderBottom = function (root) {
    if (root == null) {
      return []
    }
    const queue = [];
    queue.push(root);
    const res = [];

    while (queue.length) {
      const subRes = [];
      const levelSize = queue.length;
      for (let i = 0; i < levelSize; i++) {
        const cur = queue.shift();
        subRes.push(cur.val);
        if (cur.left) {
          queue.push(cur.left);
        }
        if (cur.right) {
          queue.push(cur.right);
        }
      }
      res.unshift(subRes);
    }
    return res;

  };


  // 108. 将有序数组转换为二叉搜索树
  /**
   * Definition for a binary tree node.
   * function TreeNode(val) {
   * this.val = val;
   * this.left = this.right = null;
   * }
   */
  /**
   * @param {number[]} nums
   * @return {TreeNode} 
   */
  var sortedArrayToBST = function (nums, start = 0, end = nums.length, mid) {
    return start === end ? null : (mid = start + (end - start >> 1), {
      val: nums[mid],
      left: sortedArrayToBST(nums, start, mid),
      right: sortedArrayToBST(nums, mid + 1, end)
    })
  };


  // 110. 平衡二叉树
  /**
   * Definition for a binary tree node.
   * function TreeNode(val, left, right) {
   * this.val = (val===undefined ? 0 : val)
   * this.left = (left===undefined ? null : left)
   * this.right = (right===undefined ? null : right)
   * }
   */
  /**
   * @param {TreeNode} root
   * @return {boolean}
   */
  var isBalanced = function (root) {
    let balanced = function (node) {
      if (!node) return 0
      const left = balanced(node.left)
      const right = balanced(node.right)
      if (left === -1 || right === -1 || Math.abs(left - right) > 1) {
        return -1
      }
      return Math.max(left, right) + 1
    }
    return balanced(root) !== -1
  };


  // 111. 二叉树的最小深度
  /**
   * Definition for a binary tree node.
   * function TreeNode(val, left, right) {
   * this.val = (val===undefined ? 0 : val)
   * this.left = (left===undefined ? null : left)
   * this.right = (right===undefined ? null : right)
   * }
   */
  /**
   * @param {TreeNode} root
   * @return {number}
   */
  var minDepth = function (root) {
    if (root == null) return 0
    if (root.left && root.right) { // 左右子树都存在，当前节点的高度1+左右子树递归结果的较小值
      return 1 + Math.min(minDepth(root.left), minDepth(root.right));
    } else if (root.left) { // 左子树存在，右子树不存在
      return 1 + minDepth(root.left);
    } else if (root.right) { // 右子树存在，左子树不存在
      return 1 + minDepth(root.right);
    } else { // 左右子树都不存在，光是当前节点的高度1
      return 1;
    }
  };


  // 112. 路径总和
  /**
   * Definition for a binary tree node.
   * function TreeNode(val) {
   * this.val = val;
   * this.left = this.right = null;
   * }
   */
  /**
   * @param {TreeNode} root
   * @param {number} sum
   * @return {boolean}
   */
  var hasPathSum = function (root, sum) {
    if (root == null) return false;
    if (root.left == null && root.right == null) {
      return sum - root.val == 0;
    }
    return hasPathSum(root.left, sum - root.val) || hasPathSum(root.right, sum - root.val);
  };



  // 118. 杨辉三角
  /**
   * @param {number} numRows
   * @return {number[][]}
   */
  var generate = function (numRows) {
    let result = []
    if (!numRows) return result
    while (result.length !== numRows) {
      let rutLen = result.length
      let l = rutLen + 1
      let arr = []
      for (let i = 0; i < l; i++) {
        let _arr = result[rutLen - 1]
        arr.push((!i || i == l - 1) ? 1 : (_arr[i - 1] + _arr[i]))
      }
      result.push(arr)
    }
    return result
  };


  // 119. 杨辉三角 II
  /**
   * @param {number} rowIndex
   * @return {number[]}
   */
  var getRow = function (rowIndex) {

    let result = [];
    result.push(1);
    for (let i = 1; i <= rowIndex; i++) {
      for (let j = i - 1; j > 0; j--) {
        result[j] = result[j - 1] + result[j]
      }
      result.push(1)
    }
    return result;


    // 公式
    // let ans = [];
    // let l = rowIndex;
    // let pre = 1;
    // ans.push(1);
    // for (let k = 1; k <= l; k++) {
    //   let cur = pre * (l - k + 1) / k;
    //   ans.push(cur);
    //   pre = cur;
    // }
    // return ans;
  };



  // 121. 买卖股票的最佳时机
  /**
   * @param {number[]} prices
   * @return {number}
   */
  var maxProfit = function (prices) {
    let max = 0,
      minprice = prices[0]
    for (let i = 1; i < prices.length; i++) {
      minprice = Math.min(prices[i], minprice)
      max = Math.max(max, prices[i] - minprice)
    }
    return max
  };



  // 122. 买卖股票的最佳时机 II
  /**
   * @param {number[]} prices
   * @return {number}
   */
  var maxProfitA = function (prices) {
    let profit = 0;
    for (let i = 1; i < prices.length; i++) {
      const diff = prices[i] - prices[i - 1];
      if (diff > 0) {
        profit += diff;
      }
    }
    return profit;
  };



  // 125. 验证回文串
  /**
   * @param {string} s
   * @return {boolean}
   */
  var isPalindrome = function (s) {
    let str = s.toLocaleLowerCase()
    let arr = str.split('')
    let l = 0
    let r = arr.length - 1
    while (l < r) {
      if (arr[l] < '0' || (arr[l] > '9' && arr[l] < 'a') || arr[l] > 'z') {
        l++
        continue
      }
      if (arr[r] < '0' || (arr[r] > '9' && arr[r] < 'a') || arr[r] > 'z') {
        r--
        continue
      }
      if (arr[l] == arr[r]) {
        l++
        r--
      } else {
        return false
      }
    }
    return true
  };



  // 136. 只出现一次的数字
  /**
   * @param {number[]} nums
   * @return {number}
   */
  var singleNumber = function (nums) {
    // let arr = []
    // for (let i = 0; i < nums.length; i++) {
    //   let idx = arr.indexOf(nums[i])
    //   if (idx !== -1) {
    //     arr.splice(idx, 1)
    //   } else {
    //     arr.push(nums[i])
    //   }
    // }
    // return arr[0]

    // 异或运算
    let ans = 0;
    for (const num of nums) {
      ans ^= num;
    }
    return ans;
  };



  // 141. 环形链表
  /**
   * Definition for singly-linked list.
   * function ListNode(val) {
   * this.val = val;
   * this.next = null;
   * }
   */

  /**
   * @param {ListNode} head
   * @return {boolean}
   */
  var hasCycle = function (head) {
    let map = new Map();
    while (head) {
      if (map.has(head)) return true;
      map.set(head, true); // 存的是节点的地址引用，而不是节点值
      head = head.next;
    }
    return false;

    // let fast = head;
    // let slow = head;
    // while (fast) {
    //   if (fast.next == null) return false;
    //   slow = slow.next;
    //   fast = fast.next.next;
    //   if (slow == fast) return true;
    // }
    // return false;
  };



  // 155. 最小栈
  /**
   * initialize your data structure here.
   */
  var MinStack = function () {
    this.stack = []
    this.minStack = []
  };

  /**
   * @param {number} x
   * @return {void}
   */
  MinStack.prototype.push = function (x) {
    this.stack.push(x)
    this.minStack.push(this.minStack.length ? Math.min(this.minStack[this.minStack.length - 1], x) : x)
  };

  /**
   * @return {void}
   */
  MinStack.prototype.pop = function () {
    this.stack.pop()
    this.minStack.pop()
  };

  /**
   * @return {number}
   */
  MinStack.prototype.top = function () {
    return this.stack[this.stack.length - 1]
  };

  /**
   * @return {number}
   */
  MinStack.prototype.getMin = function () {
    return this.minStack[this.minStack.length - 1]
  };

  /**
   * Your MinStack object will be instantiated and called as such:
   * var obj = new MinStack()
   * obj.push(x)
   * obj.pop()
   * var param_3 = obj.top()
   * var param_4 = obj.getMin()
   */



  // 160. 相交链表
  /**
   * Definition for singly-linked list.
   * function ListNode(val) {
   * this.val = val;
   * this.next = null;
   * }
   */

  /**
   * @param {ListNode} headA
   * @param {ListNode} headB
   * @return {ListNode}
   */
  var getIntersectionNode = function (headA, headB) {
    if (!headA || !headB) return null
    let pa = headA
    pb = headB

    while (pa !== pb) {
      pa = pa === null ? headB : pa.next
      pb = pb === null ? headA : pb.next
    }

    return pa
  };



  // 167. 两数之和 II - 输入有序数组
  /**
   * @param {number[]} numbers
   * @param {number} target
   * @return {number[]}
   */
  var twoSum = function (numbers, target) {
    let len = numbers.length
    if (len) {
      let left = 0
      let right = len - 1
      while (left < right) {
        if (numbers[left] + numbers[right] === target) {
          return [left + 1, right + 1]
        } else if (numbers[left] + numbers[right] > target) {
          right--
        } else {
          left++
        }
      }
    }
    return []
  };


  // 168. Excel表列名称
  /**
   * @param {number} n
   * @return {string}
   */
  var convertToTitle = function (n) {
    let ans = ''
    while (n > 0) {
      n--
      ans += String.fromCharCode((65 + (n % 26)))
      n = Math.floor(n / 26)
    }
    return ans.split('').reverse().join('')
  };


  // 169. 多数元素
  /**
   * @param {number[]} nums
   * @return {number}
   */
  var majorityElement = function (nums) {
    let x = 0
    let m = 0
    for (let n of nums) {
      if (m === 0) x = n
      m += x === n ? 1 : -1
    }
    return x
  };



  // 171. Excel表列序号
  /**
   * @param {string} s
   * @return {number}
   */
  var titleToNumber = function (s) {
    let arr = s.split('')
    let n = arr.length
    let res = 0
    for (let i = 0; i < arr.length; i++)
      res += (arr[i].charCodeAt() - 65 + 1) * Math.pow(26, n - i - 1)
    return res
  };


  // 172. 阶乘后的零
  /**
   * @param {number} n
   * @return {number}
   */
  var trailingZeroes = function (n) {
    let c = 0
    while (n >= 5) {
      n = Math.floor(n / 5)
      c += n
    }
    return c
  };



  // 190. 颠倒二进制位
  /**
   * @param {number} n - a positive integer
   * @return {number} - a positive integer
   */
  var reverseBits = function (n) {
    return parseInt(n.toString(2).padStart(32, 0).split('').reverse().join(''), 2)
  };



  // 191. 位1的个数
  /**
   * @param {number} n - a positive integer
   * @return {number}
   */
  var hammingWeight = function (n) {
    return n.toString(2).replace(/0/g, '').length
  };


  // 198. 打家劫舍
  /**
   * @param {number[]} nums
   * @return {number}
   */
  var rob = function (nums) {
    if (!nums || !nums.length) return 0
    const n = nums.length
    if (n <= 2) return Math.max(...nums)

    const dp = [nums[0], Math.max(nums[0], nums[1]), ...new Array(n - 2).fill(0)]
    for (let i = 2; i < n; i++) {
      dp[i] = Math.max(dp[i - 1], nums[i] + dp[i - 2])
    }
    return dp[n - 1]
  };



  // 202. 快乐数
  /**
   * @param {number} n
   * @return {boolean}
   */
  var isHappy = function (n) {
    if (n <= 0) return false
    let result = n
    let arr = [n]
    while (true) {
      if (result === 1) {
        break
      }
      let _arr = result.toString().split('')
      result = _arr.reduce((a, b) => a + Math.pow(Number(b), 2), 0)
      if (arr.indexOf(result) !== -1) {
        break
      }
      arr.push(result)
    }
    return result === 1
  };



  // 203. 移除链表元素
  /**
   * Definition for singly-linked list.
   * function ListNode(val) {
   * this.val = val;
   * this.next = null;
   * }
   */
  /**
   * @param {ListNode} head
   * @param {number} val
   * @return {ListNode}
   */
  var removeElements = function (head, val) {
    let res = new ListNode()
    res.next = head
    let node = res
    while (node.next) {
      if (node.next.val === val) {
        node.next = node.next.next
      } else {
        node = node.next
      }
    }
    return res.next
  };



  // 204. 计数质数
  /**
   * @param {number} n
   * @return {number}
   */
  var countPrimes = function (n) {
    // 判断是不是质数（把他的倍数（肯定不是质数）都干掉）
    const isPrime = new Array(n).fill(1)
    let ans = 0
    for (let i = 2; i < n; ++i) {
      if (isPrime[i]) {
        ans += 1
        for (let j = i * i; j < n; j += i) {
          isPrime[j] = 0
        }
      }
    }
    return ans
  };



  // 205. 同构字符串
  /**
   * @param {string} s
   * @param {string} t
   * @return {boolean}
   */
  var isIsomorphic = function (s, t) {
    if (s.length !== t.length) return false
    for (let i = 0; i < s.length; i++) {
      if (s.indexOf(s[i]) != t.indexOf(t[i])) {
        return false;
      }
    }
    return true;
  };



  // 反转一个单链表。
  /**
   * Definition for singly-linked list.
   * function ListNode(val) {
   * this.val = val;
   * this.next = null;
   * }
   */
  /**
   * @param {ListNode} head
   * @return {ListNode}
   */
  var reverseList = function (head) {
    let res = null
    while (head) {
      let node = res
      res = new ListNode(head.val)
      res.next = node
      head = head.next
    }
    return res

    // let [prev, curr] = [null, head]
    // while (curr) {
    //   [curr.next, prev, curr] = [prev, curr, curr.next]
    // }
    // return prev

  };



  // 217. 存在重复元素
  /**
   * @param {number[]} nums
   * @return {boolean}
   */
  var containsDuplicate = function (nums) {
    if (nums.length < 2) return false
    // let obj = {}
    while (nums.length) {
      let v = nums.shift()
      // if (obj[v]) return true
      // obj[v] = 1
      if (nums.indexOf(v) !== -1) return true
    }
    return false


    // return new Set(nums).size !== nums.length
  };




  // 219. 存在重复元素 II
  /**
   * @param {number[]} nums
   * @param {number} k
   * @return {boolean}
   */
  var containsNearbyDuplicate = function (nums, k) {
    if (k <= 0) return false
    for (let i = 0; i < nums.length; i++) {
      let v = nums[i]
      for (let j = i + 1; j < Math.min((i + k + 1), nums.length); j++) {
        if (nums[j] === v) return true
      }
    }
    return false


    // 维护一个最大长度为k的set,没有值就插入，超出就删除最开始的，有值，满足条件
    // const set = new Set();
    // for (let i = 0; i < nums.length; i++) {
    //   if (set.has(nums[i])) {
    //     return true;
    //   }
    //   set.add(nums[i]);
    //   if (set.size > k) {
    //     set.delete(nums[i - k]);
    //   }
    // }
    // return false;

  };




  // 225. 用队列实现栈
  /**
   * Initialize your data structure here.
   */
  var MyStack = function () {
    this.stack = []
  };

  /**
   * Push element x onto stack.
   * @param {number} x
   * @return {void}
   */
  MyStack.prototype.push = function (x) {
    this.stack[this.stack.length] = x
  };

  /**
   * Removes the element on top of the stack and returns that element.
   * @return {number}
   */
  MyStack.prototype.pop = function () {
    if (this.empty()) {
      return undefined
    }
    let v = this.stack[this.stack.length - 1]
    this.stack.length = this.stack.length - 1
    return v
  };

  /**
   * Get the top element.
   * @return {number}
   */
  MyStack.prototype.top = function () {
    return this.stack.length ? this.stack[this.stack.length - 1] : undefined
  };

  /**
   * Returns whether the stack is empty.
   * @return {boolean}
   */
  MyStack.prototype.empty = function () {
    return this.stack.length === 0
  };

  /**
   * Your MyStack object will be instantiated and called as such:
   * var obj = new MyStack()
   * obj.push(x)
   * var param_2 = obj.pop()
   * var param_3 = obj.top()
   * var param_4 = obj.empty()
   */





  // 226. 翻转二叉树
  /**
   * Definition for a binary tree node.
   * function TreeNode(val) {
   * this.val = val;
   * this.left = this.right = null;
   * }
   */
  /**
   * @param {TreeNode} root
   * @return {TreeNode}
   */
  var invertTree = function (root) {
    if (!root) return null
    let left = invertTree(root.left)
    let right = invertTree(root.right)
    root.left = invertTree(root.right)
    root.right = invertTree(root.left)
    return root


    // const queue = [root]
    // while (queue.length) {
    //   const cur = queue.shift();
    //   [cur.left, cur.right] = [cur.right, cur.left]
    //   if (cur.left) queue.push(cur.left)
    //   if (cur.right) queue.push(cur.right)
    // }
    // return root

  };




  // 228. 汇总区间
  /**
   * @param {number[]} nums
   * @return {string[]}
   */
  var summaryRanges = function (nums) {
    if (nums.length < 1) return []
    let res = []
    for (let i = 0; i < nums.length; i++) {
      let v = nums[i];
      res.push(String(v))
      for (let j = i + 1; j < nums.length; j++) {
        let _v = nums[j]
        if (_v - v === 1) {
          v = _v
          if (res[res.length - 1] !==
            String(v)) {
            res[res.length - 1] = res[res.length - 1].split('->')[0] + '->' + v
          }
          if (j === nums.length - 1) {
            i = j
          }
        } else {
          if (res[res.length - 1] !== String(v)) {
            res[res.length - 1] = res[res.length - 1].split('->')[0] + '->' + v
          }
          i = j - 1
          break
        }
      }
    }
    return res
  };




  // 231. 2的幂
  /**
   * @param {number} n
   * @return {boolean}
   */
  var isPowerOfTwo = function (n) {
    if (n === 1 || n === 2) return true
    if (n <= 0 || n % 2) return false
    let v = 2
    while (v < n) {
      v *= 2
      if (v === n) return true
    }
    return false

    // 2的幂数的数字的二进制有且只有一个1，其余均是0
    // n & (n-1)：清零最低位的1
    // return n > 0 && (n & (n-1)) == 0;


    // return n > 0 && (n & (-n)) != n
  };




  // 232. 用栈实现队列
  /**
   * Initialize your data structure here.
   */
  var MyQueue = function () {
    this.stack = []
  };

  /**
   * Push element x to the back of queue.
   * @param {number} x
   * @return {void}
   */
  MyQueue.prototype.push = function (x) {
    this.stack.push(x)
  };

  /**
   * Removes the element from in front of queue and returns that element.
   * @return {number}
   */
  MyQueue.prototype.pop = function () {
    return this.stack.shift()
  };

  /**
   * Get the front element.
   * @return {number}
   */
  MyQueue.prototype.peek = function () {
    return this.stack.length ? this.stack[0] : undefined
  };

  /**
   * Returns whether the queue is empty.
   * @return {boolean}
   */
  MyQueue.prototype.empty = function () {
    return this.stack.length === 0
  };

  /**
   * Your MyQueue object will be instantiated and called as such:
   * var obj = new MyQueue()
   * obj.push(x)
   * var param_2 = obj.pop()
   * var param_3 = obj.peek()
   * var param_4 = obj.empty()
   */




  // 234. 回文链表
  /**
   * Definition for singly-linked list.
   * function ListNode(val) {
   * this.val = val;
   * this.next = null;
   * }
   */
  /**
   * @param {ListNode} head
   * @return {boolean}
   */
  var isPalindrome = function (head) {
    let [list, node] = [
      [], head
    ]
    while (node) {
      list.push(node.val)
      node = node.next
    }
    let x = list.join("")
    return list.reverse().join("") === x

    // for (let i = 0, j = list.length - 1; i < j; ++i, --j) {
    //   if (list[i] !== list[j]) {
    //     return false;
    //   }
    // }
    // return true;

  };




  // 235. 二叉搜索树的最近公共祖先
  /**
   * Definition for a binary tree node.
   * function TreeNode(val) {
   * this.val = val;
   * this.left = this.right = null;
   * }
   */

  /**
   * @param {TreeNode} root
   * @param {TreeNode} p
   * @param {TreeNode} q
   * @return {TreeNode}
   */
  var lowestCommonAncestor = function (root, p, q) {
    // 二叉树的特点，大的右边，小的左边
    while (root) {
      if (p.val < root.val && q.val < root.val) {
        root = root.left;
      } else if (p.val > root.val && q.val > root.val) {
        root = root.right;
      } else {
        break;
      }
    }
    return root;
  };




  // 237. 删除链表中的节点
  /**
   * Definition for singly-linked list.
   * function ListNode(val) {
   * this.val = val;
   * this.next = null;
   * }
   */
  /**
   * @param {ListNode} node
   * @return {void} Do not return anything, modify node in-place instead.
   */
  var deleteNode = function (node) {
    node.val = node.next.val
    node.next = node.next.next
  };




  // 242. 有效的字母异位词
  /**
   * @param {string} s
   * @param {string} t
   * @return {boolean}
   */
  var isAnagram = function (s, t) {
    if (s.length !== t.length) return false
    return [...s].sort().join('') === [...t].sort().join('')
  };



  // 257. 二叉树的所有路径
  /**
   * Definition for a binary tree node.
   * function TreeNode(val) {
   * this.val = val;
   * this.left = this.right = null;
   * }
   */
  /**
   * @param {TreeNode} root
   * @return {string[]}
   */
  var binaryTreePaths = function (root) {
    if (root === null) return []

    const paths = []
    const node_queue = [root]
    const path_queue = [root.val.toString()]

    while (node_queue.length) {
      const node = node_queue.shift()
      const path = path_queue.shift()

      if (node.left === null && node.right === null) {
        paths.push(path)
      } else {
        if (node.left !== null) {
          node_queue.push(node.left)
          path_queue.push(path + "->" + node.left.val.toString())
        }

        if (node.right !== null) {
          node_queue.push(node.right)
          path_queue.push(path + "->" + node.right.val.toString())
        }
      }
    }
    return paths

    // const paths = [];
    // const construct_paths = (root, path) => {
    //   if (root) {
    //     path += root.val.toString();
    //     if (root.left === null && root.right === null) { // 当前节点是叶子节点
    //       paths.push(path); // 把路径加入到答案中
    //     } else {
    //       path += "->"; // 当前节点不是叶子节点，继续递归遍历
    //       construct_paths(root.left, path);
    //       construct_paths(root.right, path);
    //     }
    //   }
    // }
    // construct_paths(root, "");
    // return paths;

  };




  // 258. 各位相加
  /**
   * @param {number} num
   * @return {number}
   */
  var addDigits = function (num) {
    if (!num) return 0
    if (num < 10) return num
    let queue = [...num.toString()]
    while (queue.length !== 1) {
      let v = queue.reduce((a, b) =>
        Number(a) + Number(b))
      if (v < 10) return v
      queue = [...v.toString()]
    }
  };



  // 263. 丑数
  /**
   * @param {number} num
   * @return {boolean}
   */
  var isUgly = function (num) {
    if (num < 1) return false;
    [2, 3, 5].map(item => {
      while (num % item === 0) num /= item
    })
    return num === 1
  };



  // 268. 丢失的数字
  /**
   * @param {number[]} nums
   * @return {number}
   */
  var missingNumber = function (nums) {
    return ((1 + nums.length) * nums.length / 2) - nums.reduce((a, b) => a + b)
  };




  // 278. 第一个错误的版本
  /**
   * Definition for isBadVersion()
   *
   * @param {integer} version number
   * @return {boolean} whether the version is bad
   * isBadVersion = function(version) {
   * ...
   * };
   */

  /**
   * @param {function} isBadVersion()
   * @return {function}
   */
  var solution = function (isBadVersion) {
    /**
     * @param {integer} n Total versions
     * @return {integer} The first bad version
     */
    return function (n) {
      let l = 1
      let r = n
      while (l < r) {
        let mid = l + Math.floor((r - l) / 2)
        if (isBadVersion(mid) == false) {
          l = mid + 1
        } else {
          r = mid
        }
      }
      return l
    }
  };




  // 283. 移动零
  /**
   * @param {number[]} nums
   * @return {void} Do not return anything, modify nums in-place instead.
   */
  var moveZeroes = function (nums) {
    nums.sort((a, b) => a === 0 ? b !== 0 ? 1 : 0 : b === 0 ? -1 : 0)
  };




  // 290. 单词规律
  /**
   * @param {string} pattern
   * @param {string} s
   * @return {boolean}
   */
  var wordPattern = function (pattern, s) {
    let arr = s.split(' ')
    if (arr.length !== pattern.length) return false
    let obja = {},
      objb = {}
    for (let i = 0; i < arr.length; i++) {
      let a = arr[i],
        b = pattern[i]
      if (obja.hasOwnProperty(a)) {
        if (obja[a] !== b)
          return false
      } else {
        obja[a] = b
      }
      if (objb.hasOwnProperty(b)) {
        if (objb[b] !== a) return false
      } else {
        objb[b] = a
      }
    }
    return true
  };




  // 292. Nim 游戏
  /**
   * @param {number} n
   * @return {boolean}
   */
  var canWinNim = function (n) {
    return n % 4
  };





  // 303. 区域和检索 - 数组不可变
  /**
   * @param {number[]} nums
   */
  var NumArray = function (nums) {
    this.list = nums || []
  };

  /**
   * @param {number} i
   * @param {number} j
   * @return {number}
   */
  NumArray.prototype.sumRange = function (i, j) {
    if (!this.list.length || i > j || i < 0 || j > this.list.length) return 0
    let sun = 0;
    for (; i <= j; i++) {
      sun += this.list[i]
    }
    return sun
  };

  /**
   * Your NumArray object will be instantiated and called as such:
   * var obj = new NumArray(nums)
   * var param_1 = obj.sumRange(i,j)
   */




  // 326. 3的幂
  /**
   * @param {number} n
   * @return {boolean}
   */
  var isPowerOfThree = function (n) {
    let val = 1
    while (n > val) {
      val *= 3
    }
    return n === val
  };




  // 342. 4的幂
  /**
   * @param {number} n
   * @return {boolean}
   */
  var isPowerOfFour = function (n) {
    let val = 1
    while (n > val) {
      val *= 4
    }
    return n === val
  };




  // 344. 反转字符串
  /**
   * @param {character[]} s
   * @return {void} Do not return anything, modify s in-place instead.
   */
  var reverseString = function (s) {
    if (!s.length) return []
    let l = 0,
      r = s.length - 1
    while (l < r) {
      [s[l], s[r]] = [s[r], s[l]]
      l++
      r--
    }
  };




  // 345. 反转字符串中的元音字母
  /**
   * @param {string} s
   * @return {string}
   */
  var reverseVowels = function (s) {
    if (!s.length) return ''
    let list = s.split('')
    let l = 0,
      r = s.length - 1
    while (l < r) {
      let arr = ['a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U']
      if (arr.includes(list[l]) && arr.includes(list[r])) {
        [list[l], list[r]] = [list[r], list[l]]
        l++
        r--
      } else {
        if (!arr.includes(list[l])) l++
        if (!arr.includes(list[r])) r--
      }
    }
    return list.join('')
  };




  // 349. 两个数组的交集
  /**
   * @param {number[]} nums1
   * @param {number[]} nums2
   * @return {number[]}
   */
  var intersection = function (nums1, nums2) {
    let arr1 = nums1,
      arr2 = nums2;
    if (nums1.length > nums2.length) {
      arr1 = nums2
      arr2 = nums1
    }
    let result = []
    for (let i = 0; i < arr1.length; i++) {
      let v = arr1[i]
      if (arr2.includes(v) && result.indexOf(v) === -1) {
        result.push(v)
      }
    }
    return result
  };




  // 350. 两个数组的交集 II
  /**
   * @param {number[]} nums1
   * @param {number[]} nums2
   * @return {number[]}
   */
  var intersect = function (nums1, nums2) {
    let arr1 = nums1,
      arr2 = nums2;
    if (nums1.length > nums2.length) {
      arr1 = nums2
      arr2 = nums1
    }
    let result = []

    while (arr1.length) {
      let v = arr1.shift()
      if (arr2.includes(v)) {
        result.push(v)
        arr2.splice(arr2.indexOf(v), 1)
      }
    }
    return result
  };




  // 367. 有效的完全平方数
  /**
   * @param {number} num
   * @return {boolean}
   */
  var isPerfectSquare = function (num) {
    // 1+3+5+7+...+(2N−1)=N^2
    if (num == 1) {
      return 1;
    }
    var tmp = 1;
    while (num > 0) {
      num -= tmp;
      tmp += 2;
    }
    return num == 0;
  };





  // 371. 两整数之和
  /**
   * @param {number} a
   * @param {number} b
   * @return {number}
   */
  var getSum = function (a, b) {
    while (b) sum = a ^ b, b = (a & b) << 1, a = sum
    return sum
  };




  // 374. 猜数字大小
  /**
   * Forward declaration of guess API.
   * @param {number} num your guess
   * @return -1 if num is lower than the guess number
   * 1 if num is higher than the guess number
   * otherwise return 0
   * var guess = function(num) {}
   */

  /**
   * @param {number} n
   * @return {number}
   */
  var guessNumber = function (n, l = 1) {
    let left = 1,
      right = n
    while (left <= right) {
      const middle = left + ((right - left) >> 1)
      if (guess(middle) === 0) {
        return middle
      } else if (guess(middle) > 0) {
        left = middle + 1
      } else {
        right = middle - 1
      }
    }
    return left
  };




  // 383. 赎金信
  /**
   * @param {string} ransomNote
   * @param {string} magazine
   * @return {boolean}
   */
  var canConstruct = function (ransomNote, magazine) {
    for (let i = 0; i < ransomNote.length; i++) {
      if (magazine.indexOf(ransomNote[i]) === -1) {
        return false;
      }
      magazine = magazine.replace(ransomNote[i], "");
    }
    return true;
  };




  // 387. 字符串中的第一个唯一字符
  /**
   * @param {string} s
   * @return {number}
   */
  var firstUniqChar = function (s) {
    let _s = s;
    let arr = _s.split('')
    while (arr.length) {
      let v = arr.shift()
      if (arr.indexOf(v) !== -1) {
        _s = _s.replace(new RegExp(v, 'g'), '')
        arr = _s.split('')
      } else {
        return s.indexOf(v)
      }
    }
    return -1
  };





  // 389. 找不同
  /**
   * @param {string} s
   * @param {string} t
   * @return {character}
   */
  var findTheDifference = function (s, t) {
    while (t.length) {
      if (s.indexOf(t[0]) !== -1) {
        s = s.replace(t[0], '')
        t = t.replace(t[0], '')
      } else {
        return t[0]
      }
    }
  };




  // 392. 判断子序列
  /**
   * @param {string} s
   * @param {string} t
   * @return {boolean}
   */
  var isSubsequence = function (s, t) {
    let arr = s.split('')
    for (let i = 0; i < t.length; i++) {
      if (t[i] === arr[0]) {
        arr.shift()
        if (arr.length == 0) return true
      }
    }
    return !arr.length
  };




  // 401. 二进制手表
  /**
   * @param {number} num
   * @return {string[]}
   */
  var readBinaryWatch = function (num) {
    // 这个数组中num个数的排列组合
    const arr = [1, 2, 4, 8, 1, 2, 4, 8, 16, 32]
    const result = []

    let backTrace = function (arr, num, start, temp, result) {
      if (temp[0] >= 12 || temp[1] >= 60) return
      if (num === 0) {
        result.push(`${temp[0]}:${padding(temp[1])}`)
        return
      }

      for (let i = start; i < arr.length; i++) {
        if (i <= 3) {
          temp[0] = temp[0] + arr[i]
        } else {
          temp[1] = temp[1] + arr[i]
        }
        num = num - 1
        backTrace(arr, num, i + 1, temp, result)
        if (i <= 3) {
          temp[0] = temp[0] - arr[i]
        } else {
          temp[1] = temp[1] - arr[i]
        }
        num = num + 1
      }
    }
    let padding = function (num) {
      return num < 10 ? `0${num}` : num
    }

    backTrace(arr, num, 0, [0, 0], result)
    return result
  };





  // 404. 左叶子之和
  /**
   * Definition for a binary tree node.
   * function TreeNode(val) {
   * this.val = val;
   * this.left = this.right = null;
   * }
   */
  /**
   * @param {TreeNode} root
   * @return {number}
   */
  var sumOfLeftLeaves = function (root) {
    if (!root) return 0
    let queue = [root]
    let count = 0
    while (queue.length) {
      let node = queue.shift()
      let l = node.left
      if (l) {
        if (l.left === l.right && l.left === null) count += l.val
        else queue.push(l)
      }
      if (node.right) {
        queue.push(node.right)
      }
    }
    return count
  };




  // 405. 数字转换为十六进制数
  /**
   * @param {number} num
   * @return {string}
   */
  var toHex = function (num) {
    let resnum = 1;
    let hex = "0123456789abcdef";
    let res = "";
    if (!num) return "0";
    else {
      while (num && resnum <= 8) {
        res = hex[num & 0x0000f] + res;
        num >>= 4;
        resnum++;
      }
    }
    return res;
  };




  // 409. 最长回文串
  /**
   * @param {string} s
   * @return {number}
   */
  var longestPalindrome = function (s) {
    if (!s.length) return 0
    let arr = []
    let result = 0
    for (let i = 0; i < s.length; i++) {
      let x = arr.indexOf(s[i])
      if (x !== -1) {
        arr.splice(x, 1)
        result += 2
      } else {
        arr.push(s[i])
      }
    }
    return result < s.length ? result + 1 : result
  };





  // 412. Fizz Buzz 
  /**
   * @param {number} n
   * @return {string[]}
   */
  var fizzBuzz = function (n) {
    let arr = []
    for (let i = 1; i < n + 1; i++) {
      if (i % 15 === 0) {
        arr.push('FizzBuzz')
      } else if (i % 5 === 0) {
        arr.push('Buzz')
      } else if (i % 3 === 0) {
        arr.push('Fizz')
      } else {
        arr.push(String(i))
      }
    }
    return arr
  };




  // 414. 第三大的数
  /**
   * @param {number[]} nums
   * @return {number}
   */
  var thirdMax = function (nums) {
    let arr = [...new Set(nums)]
    arr = arr.sort((a, b) => b - a)
    return arr.length > 2 ? arr[2] : arr[0]
  };




  // 415. 字符串相加
  /**
   * @param {string} num1
   * @param {string} num2
   * @return {string}
   */
  var addStrings = function (num1, num2) {
    let i = num1.length - 1,
      j = num2.length - 1,
      add = 0;
    const ans = [];
    while (i >= 0 || j >= 0 || add != 0) {
      const x = i >= 0 ? num1.charAt(i) - '0' : 0;
      const y = j >= 0 ? num2.charAt(j) - '0' : 0;
      const result = x + y + add;
      ans.push(result % 10);
      add = Math.floor(result / 10);
      i -= 1;
      j -= 1;
    }
    return ans.reverse().join('');
  };





  // 434. 字符串中的单词数
  /**
   * @param {string} s
   * @return {number}
   */
  var countSegments = function (s) {
    return s.split(' ').filter(item => item !== '').length
  };





  // 441. 排列硬币
  /**
   * @param {number} n
   * @return {number}
   */
  var arrangeCoins = function (n) {
    let count = 0
    let x = 0
    while (n > count) {
      x++
      count = count + x
      if ((n - count - x - 1) < 0) {
        break
      }
    }
    return x

    // if (n == 0) return 0;
    // let left = 0;
    // let right = n;
    // while (left <= right) {
    //   let mid = left + ((right - left) >> 1);
    //   let costToFinishMid = (1 + mid) * mid / 2;
    //   if (costToFinishMid == n) {
    //     return mid;
    //   } else if (costToFinishMid < n) {
    //     left = mid + 1;
    //   } else if (costToFinishMid > n) {
    //     right = mid - 1;
    //   }
    // }
    // return right;
  };




  // 448. 找到所有数组中消失的数字
  /**
   * @param {number[]} nums
   * @return {number[]}
   */
  var findDisappearedNumbers = function (nums) {
    let l = nums.length,
      arr = []
    for (let i = 0; i < l; i++) {
      if (nums.indexOf(i + 1) === -1) {
        arr.push(i + 1)
      }
    }
    return arr
  };




  // 453. 最小操作次数使数组元素相等
  /**
   * @param {number[]} nums
   * @return {number}
   */
  var minMoves = function (nums) {
    let moves = 0;
    for (let i = 0; i < nums.length; i++) {
      moves += nums[i] - Math.min(...nums);
    }
    return moves;


    // let moves = 0;
    // for (let i = 0; i < nums.length; i++) {
    //   moves += nums[i];
    // }
    // return moves - Math.min(...nums) * nums.length;
  }




  // 455. 分发饼干
  /**
   * @param {number[]} g
   * @param {number[]} s
   * @return {number}
   */
  var findContentChildren = function (g, s) {
    let arrg = g.sort((a, b) => b - a),
      arrs = s.sort((a, b) => b - a),
      count = 0;
    while (arrs.length || arrg.length) {
      let v = arrs.shift()
      while (arrg.length) {
        if (v >= arrg.shift()) {
          count++
          break
        }
      }
    }
    return count
  };





  // 459. 重复的子字符串
  /**
   * @param {string} s
   * @return {boolean}
   */
  var repeatedSubstringPattern = function (s) {
    let s1 = (s + s).slice(1, -1);
    return s1.indexOf(s) != -1;
  };




  // 461. 汉明距离
  /**
   * @param {number} x
   * @param {number} y
   * @return {number}
   */
  var hammingDistance = function (x, y) {
    // 异或
    return (x ^ y).toString(2).replace(/0/g, '').length
  };





  // 463. 岛屿的周长
  /**
   * @param {number[][]} grid
   * @return {number}
   */
  var islandPerimeter = function (grid) {
    // let count = 0;

    // for (let i = 0; i < grid.length; i++) {
    //   count += 2 * continuous(grid[i]); // 行，有几个1（连续算1个）
    //   // 正方形可以用这个
    //   // count += 2 * continuous(grid.map(item => item[i])); // 列，有几个1（连续算1个）
    // }
    // for (let i = 0; i < grid[0].length; i++) {
    //   count += 2 * continuous(grid.map(item => item[i])); // 列，有几个1（连续算1个）
    // }

    // function continuous(list) {
    //   console.log('list为', list)
    //   let c = 0,
    //     _list = [...list];
    //   while (_list.length) {
    //     let v = _list.shift()
    //     if (v && !_list[0]) {
    //       c++
    //     }
    //   }
    //   return c
    // }
    // return count



    let land = 0; // 土地个数
    let border = 0; // 接壤边界的条数

    for (let i = 0; i < grid.length; i++) {
      for (let j = 0; j < grid[0].length; j++) {
        if (grid[i][j] == 1) {
          land++;
          if (i < grid.length - 1 && grid[i + 1][j] == 1) {
            border++;
          }
          if (j < grid[0].length - 1 && grid[i][j + 1] == 1) {
            border++;
          }
        }
      }
    }
    return 4 * land - 2 * border;
  };





  // 476. 数字的补数
  /**
   * @param {number} num
   * @return {number}
   */
  var findComplement = function (num) {
    let binary = num.toString(2);
    let complement = '';
    for (i = 0, len = binary.length; i < len; i++) {
      complement += binary[i] ^ 1;
    }
    return parseInt(complement, 2);
  };





  // 482. 密钥格式化
  /**
   * @param {string} S
   * @param {number} K
   * @return {string}
   */
  var licenseKeyFormatting = function (S, K) {
    let str = S.toLocaleUpperCase().split('-').join('')
    let l = str.length > K ? str.length % K : 0
    let _s = str.substring(0, l) + '-'
    if (l) {
      str = str.substring(l)
    }
    str = str.replace(new RegExp(`(.{${K}})`, 'g'), '$1-')
    if (str[str.length - 1] == '-') str = str.substring(0, str.length - 1)
    return l ? _s + str : str
  };





  // 485. 最大连续1的个数
  /**
   * @param {number[]} nums
   * @return {number}
   */
  var findMaxConsecutiveOnes = function (nums) {
    let arr = nums.join('').split('0')
    return Math.max(...arr.map(i => i.length))
  };





  // 492. 构造矩形 
  /**
   * @param {number} area
   * @return {number[]}
   */
  var constructRectangle = function (area) {
    let p = Math.floor(Math.sqrt(area))

    // let result = []
    // for (let i = 1; i <= p; i++) {
    //   if (area % i == 0) {
    //     result = [area / i, i]
    //   }
    // }
    // return result

    for (let i = p; i > 0; i--) {
      if (area % i == 0) {
        let j = area / i
        return j < i ? [i, j] : [j, i]
      }
    }
  };





  // 496. 下一个更大元素 I
  /**
   * @param {number[]} nums1
   * @param {number[]} nums2
   * @return {number[]}
   */
  var nextGreaterElement = function (nums1, nums2) {
    let result = new Array(nums1.length).fill(-1)
    for (let i = 0; i < result.length; i++) {
      for (let j = (nums2.indexOf(nums1[i]) + 1); nums2.length - j >= 0; j++) {
        if (nums2[j] > nums1[i]) {
          result[i] = nums2[j]
          break
        }
      }
    }
    return result


    // let hashMap = {}
    // let stack = []
    // for (let i = 0; i < nums2.length; i++) {
    //   while (stack.length && nums2[i] > stack[stack.length - 1]) {
    //     hashMap[stack.pop()] = nums2[i]
    //   }
    //   stack.push(nums2[i])
    // }
    // while (stack.length) {
    //   hashMap[stack.pop()] = -1
    // }
    // return nums1.map(item => hashMap[item])
  };





  // 500. 键盘行
  /**
   * @param {string[]} words
   * @return {string[]}
   */
  var findWords = function (words) {
    const hashMap = {
      'Q': -1,
      'q': -1,
      'W': -1,
      'w': -1,
      'E': -1,
      'e': -1,
      'R': -1,
      'r': -1,
      'T': -1,
      't': -1,
      'Y': -1,
      'y': -1,
      'U': -1,
      'u': -1,
      'I': -1,
      'i': -1,
      'O': -1,
      'o': -1,
      'P': -1,
      'p': -1,
      'A': 0,
      'a': 0,
      'S': 0,
      's': 0,
      'D': 0,
      'd': 0,
      'F': 0,
      'f': 0,
      'G': 0,
      'g': 0,
      'H': 0,
      'h': 0,
      'J': 0,
      'j': 0,
      'K': 0,
      'k': 0,
      'L': 0,
      'l': 0,
      'Z': 1,
      'z': 1,
      'X': 1,
      'x': 1,
      'C': 1,
      'c': 1,
      'V': 1,
      'v': 1,
      'B': 1,
      'b': 1,
      'N': 1,
      'n': 1,
      'M': 1,
      'm': 1,
    }
    return words.filter(item => {
      if (item.length > 1) {
        let arr = item.split('')
        for (let i = 1; i < arr.length; i++) {
          if (hashMap[arr[i]] !== hashMap[arr[0]]) return false
        }
      }
      return true
    })
  };






  // 501. 二叉搜索树中的众数
  /**
   * Definition for a binary tree node.
   * function TreeNode(val) {
   * this.val = val;
   * this.left = this.right = null;
   * }
   */
  /**
   * @param {TreeNode} root
   * @return {number[]}
   */
  var findMode = function (root) {
    if (!root) return []
    let hashMap = {}
    let queue = [root]
    let maxCount = 0
    let result = []
    while (queue.length) {
      let cur = queue.shift()
      let k = cur.val
      hashMap[k] = hashMap[k] ? hashMap[k] + 1 : 1
      if (hashMap[k] > maxCount) {
        result = [k]
        maxCount = hashMap[k]
      } else if (hashMap[k] == maxCount) {
        result.push(k)
      }
      if (cur.left) queue.push(cur.left)
      if (cur.right) queue.push(cur.right)
    }

    return result


    // let base = 0,
    //   count = 0,
    //   maxCount = 0;
    // let answer = [];

    // const update = (x) => {
    //   if (x === base) {
    //     ++count;
    //   } else {
    //     count = 1;
    //     base = x;
    //   }
    //   if (count === maxCount) {
    //     answer.push(base);
    //   }
    //   if (count > maxCount) {
    //     maxCount = count;
    //     answer = [base];
    //   }
    // }

    // let cur = root,
    //   pre = null;
    // while (cur !== null) {
    //   if (cur.left === null) {
    //     update(cur.val);
    //     cur = cur.right;
    //     continue;
    //   }
    //   pre = cur.left;
    //   while (pre.right !== null && pre.right !== cur) {
    //     pre = pre.right;
    //   }
    //   if (pre.right === null) {
    //     pre.right = cur;
    //     cur = cur.left;
    //   } else {
    //     pre.right = null;
    //     update(cur.val);
    //     cur = cur.right;
    //   }
    // }
    // return answer;

  };



  /**
   * @param {number} num
   * @return {string}
   */
  var convertToBase7 = function (num) {

  };
</script>